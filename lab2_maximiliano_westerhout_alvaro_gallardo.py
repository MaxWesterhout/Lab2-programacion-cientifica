# -*- coding: utf-8 -*-
"""Lab2_maximiliano_westerhout_alvaro_gallardo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q8D6IpejqwwrueMXj84n9zw3cq6_vJMR

<h1><center>Laboratorio 2: Primeros pasos üë£</center></h1>

<center><strong>MDS7202: Laboratorio de Programaci√≥n Cient√≠fica para Ciencia de Datos - Primavera 2023</strong></center>

### Cuerpo Docente:

- Profesores: Ignacio Meza, Gabriel Iturra
- Auxiliar: Sebasti√°n Tinoco
- Ayudante: Arturo Lazcano, Angelo Mu√±oz

### Equipo: SUPER IMPORTANTE - notebooks sin nombre no ser√°n revisados

- Nombre de alumno 1: √Ålvaro Gallardo
- Nombre de alumno 2: Maximiliano Westerhout

### **Link de repositorio de GitHub:** `http://....`

## Reglas:

- Fecha de entrega: 6 d√≠as desde la publicaci√≥n, 3 d√≠as de atraso con 1 punto de descuento c/u. Pueden utilizar d√≠as bonus sin descuento.
- **Grupos de 2 personas**
- Asistencia **obligatoria** a instrucciones del lab (viernes 16.15). Luego, pueden quedarse trabajando en las salas o irse.
- **Ausentes tienen nota m√°xima 6.0**.
- Cualquier duda fuera del horario de clases al foro. Mensajes al equipo docente ser√°n respondidos por este medio.
- Prohibidas las copias.
- Pueden usar cualquer material del curso que estimen conveniente.

## Objetivos del lab:

Poner en pr√°ctica los t√≥picos b√°sicos del lenguaje de programaci√≥n Python vistos en clases.

- Variables, Operadores y Expresiones.
- Estructuras de Control (if/else).
- Iteraciones.
- Listas y Diccionarios.
- Funciones
- Programaci√≥n Orientada a Objetos (Encapsulamiento, Polimorfismo y Herencia)

## Parte 1: üçã Frutas üçì [2.5 puntos]


<div align='center'>
<img src='https://upload.wikimedia.org/wikipedia/commons/a/a2/Berries_in_Berlin.jpg' width=600/>
</div>

Defina las siguientes frutas como diccionarios a partir de sus caracter√≠sticas (nombre, color, tipo y si posee o no pepas):

| Nombre    | Tipo     | Color    | Pepas |
|-----------|----------|----------|-------|
| limon     | c√≠trica  | amarillo | True  |
| naranja   | c√≠trica  | naranjo  | True  |
| pl√°tano   | tropical | amarillo | False |
| pi√±a      | tropical | amarillo | False |
| frutilla  | bosque   | rojo     | True |
| frambuesa | bosque   | rojo     | True |

### Estructurar Datos [0.5 puntos]

Agregue Pi√±a, Frutilla y Frambuesa como diccionarios (siga los ejemplos de las frutas dadas) y luego cree una lista que contenga estas frutas.
"""

limon = {
    "nombre": "lim√≥n",
    "tipo": "c√≠trica",
    "color": "amarillo",
    "pepas": True
    }

naranja = {"nombre": "naranja",
           "tipo": "c√≠trica",
           "color": "naranjo",
           "pepas": True
          }

platano = {"nombre": "pl√°tano",
           "tipo": "tropical",
           "color": "amarillo",
           "pepas": False
          }

# agregar las frutas que faltan aqu√≠

pi√±a = {"nombre": "pi√±a",
           "tipo": "tropical",
           "color": "amarillo",
           "pepas": False
          }

frutilla = {"nombre": "frutilla",
           "tipo": "bosque",
           "color": "rojo",
           "pepas": True
          }

frambuesa = {"nombre": "frambuesa",
           "tipo": "bosque",
           "color": "rojo",
           "pepas": True
          }

"""Ahora, agregue todas las frutas a una lista."""

# Ojo: agregue los datos en el mismo orden que aparecen en la tabla
datos = [limon, naranja, platano, pi√±a, frutilla, frambuesa]

"""Esta lista ser√° la informaci√≥n con la que se trabajar√° durante el lab.

### Funciones Aplicadas a los Datos [2.0 puntos]

En esta secci√≥n se les pide generar una serie de funciones que cumplan diferentes prop√≥sitos. Un aspecto clave de la programaci√≥n funcional es la apropiada **documentaci√≥n** de lo que ustedes generen. Si bien existen diferentes formas de documentar c√≥digo, una de las mas usadas es el formato docstring de `numpy`:

```python
# manual para describir:
# https://numpydoc.readthedocs.io/en/latest/format.html

# plantilla (agregar todos los argumentos que sean necesarios)
# pensar _type_ como los tipos b√°sicos que hemos visto hasta ahora: int, float, string, list, dict, tuple, set, etc...

def funcion_generica(arg1, arg2):
    '''_summary_

    Parameters
    ----------
    arg1 : _type_
        _description_
    arg2 : _type_
        _description_

    Returns
    -------
    _type_
        _description_
    '''
    return ...
```

Considerando esto y **sin olvidar la documentaci√≥n**, se les pide generar las siguientes funciones:

**1. La funci√≥n `generar_descripcion(fruta)` que reciba una fruta genere una descripci√≥n de la fruta de la siguiente manera:**

```{El/La} {...} es una fruta de tipo {...} de color {...}. {Presenta/No presenta} pepas en su interior.```
    
Por ejemplo, `generar_descripcion(pl√°tano)` debe generar el siguiente string:
    
```
'El pl√°tano es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.'
```
    
Indicaciones:
- Usen formateo o suma de strings, if, else y for.
- Para saber si ocupar 'El' o 'La', pueden acceder al nombre de la fruta y ver cual es el √∫ltimo car√°cter a trav√©s de indexadores `string[indice]`.
- Utilice los siguientes test para corroborar el funcionamiento de su c√≥digo:

```python
assert generar_descripcion(limon) == "El lim√≥n es una fruta de tipo c√≠trica de color amarillo. Presenta pepas en su interior."
assert generar_descripcion(naranja) == "La naranja es una fruta de tipo c√≠trica de color naranjo. Presenta pepas en su interior."
assert generar_descripcion(platano) == "El pl√°tano es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior."
assert generar_descripcion(pi√±a) == "La pi√±a es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior."
assert generar_descripcion(frutilla) == "La frutilla es una fruta de tipo bosque de color rojo. Presenta pepas en su interior."
assert generar_descripcion(frambuesa) == "La frambuesa es una fruta de tipo bosque de color rojo. Presenta pepas en su interior."
```
"""

def generar_descripcion(fruta):
    # Documentaci√≥n Aqu√≠
    """
    Summary
    Es una funcion que genera una descripcion de la fruta colocada

    Parameters
    ----------
    fruta: Diccionario (tipo), Corresponde un diccionario de cuatro llaves
    correspondiente a las caracteristicas de la fruta en cuestion. Estas llaves
    contienen 3 valores de tipo string y la ultima de tipo booleano correspondiente
    a posee pepas.

    Returns
    -------
    Retorna un STRING, con la informacion de las llaves de la fruta en cuestion.
    El contenido en completitud corresponde a la descripcion de la fruta.
    """
    # C√≥digo Aqu√≠
    ultimo_caracter = fruta["nombre"][-1]  # Obtenemos el √∫ltimo car√°cter de la fruta
    if ultimo_caracter in ['a']:           # Si termina en a, tiene articulo "La"
        articulo = 'La'
        nombre = fruta["nombre"]           #Distintos elementos del mensaje final
        tipo = fruta["tipo"]
        color = fruta["color"]
        pepas = "Presenta" if fruta["pepas"] else "No presenta"

        descripcion = f"{articulo} {nombre} es una fruta de tipo {tipo} de color {color}. {pepas} pepas en su interior." #Mensaje final para el caso "La"
    else:
        articulo = 'El'                   # Si termina en otra letra, tiene articulo "El"
        nombre = fruta["nombre"]
        tipo = fruta["tipo"]
        color = fruta["color"]
        pepas = "Presenta" if fruta["pepas"] else "No presenta"

        descripcion = f"{articulo} {nombre} es una fruta de tipo {tipo} de color {color}. {pepas} pepas en su interior." #Mensaje final para el caso "El"
    return descripcion #Se retorna el mensaje final

#Asserts de las distintas frutas
assert generar_descripcion(limon) == "El lim√≥n es una fruta de tipo c√≠trica de color amarillo. Presenta pepas en su interior."
assert generar_descripcion(naranja) == "La naranja es una fruta de tipo c√≠trica de color naranjo. Presenta pepas en su interior."
assert generar_descripcion(platano) == "El pl√°tano es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior."
assert generar_descripcion(pi√±a) == "La pi√±a es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior."
assert generar_descripcion(frutilla) == "La frutilla es una fruta de tipo bosque de color rojo. Presenta pepas en su interior."
assert generar_descripcion(frambuesa) == "La frambuesa es una fruta de tipo bosque de color rojo. Presenta pepas en su interior."

"""**2. La funci√≥n `describir(datos)` que generalice la funci√≥n `generar_descripcion` para recibir una lista de frutas y devolver una lista con las descripciones de cada una:**

Por ejemplo, `describir([limon, naranja]])` deber√° devolver una lista de la forma `[descripcion_limon, descripcion_naranja]`
"""

def describir(datos):
    # Documentaci√≥n Aqu√≠
    """
    Summary
    Toma una lista de diccionarios y retorna una lista con la descripcion de dichos
    diccionarios.

    Parameters
    ----------
    datos: Lista, esta conformada por diccionarios. Cada elemento corresponde a
    una fruta que posee informacion de sus respectivas caracteristicas presente
    en cuatro llaves.Estas llaves contienen 3 valores de tipo string y la ultima
    de tipo booleano correspondiente a posee pepas.

    Returns
    -------
    Retorna una lista con la descripcion de cada fruta perteneciente a la lista
    ingresada originalmente
    """
    # C√≥digo Aqu√≠
    descripciones = [] #Creamos un vector vacio
    for fruta in datos:
      descripcion = generar_descripcion(fruta) #Obtenermos la descripcion de cada fruta
      descripciones.append(descripcion)        #Rellenamos la lista
    return descripciones

describir([limon, naranja])

"""**3. La funci√≥n `filtrar_por_pepa(datos, tiene_pepas)` que dado un tipo de fruta y un booleano, retorne las frutas que tienen o no tienen pepas (seg√∫n el valor de `tiene_pepas`).**
    

Por ejemplo, `filtrar_por_pepa(datos, True)` deber√° retornar una lista con los diccionarios de: naranja, limon, frutilla y frambuesa.
"""

def filtrar_por_pepa(datos, tiene_pepas):
    # Documentaci√≥n Aqu√≠
    """
    Summary
    Toma una lista de diccionarios y un boleeano, verificando si la caracteristica
    "tiene pepas" se cunple o no dependiendo del boleeano ingresado.

    Parameters
    ----------
    datos: Lista, esta conformada por diccionarios. Cada elemento corresponde a
    una fruta que posee informacion de sus respectivas caracteristicas.

    tiene_pepas: Booleano, True implica que la fruta posee pepas y False el caso
    contrario

    Returns
    -------
    Retorna una lista con el nobre de las frutas que cumplen la condicion de
    tener o no tener pepas
    """
    # C√≥digo Aqu√≠
    filtrados = []    #Lista vacia
    for fruta in datos:
      if fruta["pepas"] == tiene_pepas:   #Se verifica si tiene pepas o no tiene
        filtrados.append(fruta["nombre"]) #Se rellena la lista
    return filtrados                      #Se retorna la lista

filtrar_por_pepa(datos, True)

filtrar_por_pepa(datos, False)

"""**4. La funci√≥n `conteo_colores(datos)` que cree un diccionario que haga un conteo los colores de las frutas.**

Para estos datos, la funci√≥n deber√≠a retornar el siguiente diccionario:
    
```python
{"amarillo": 3, "naranjo": 1, "rojo": 2}
```
"""

def conteo_colores(datos):
    # Documentaci√≥n Aqu√≠
    """
    Summary
    Toma una lista de frutas (cada uno un diccionario) y cuenta el numero de cada
    caracteristica de "Color" respectiva a cada una de ellas, retornando el numero
    total para cada color.

    Parameters
    ----------
    datos: Lista, esta conformada por diccionarios. Cada elemento corresponde a
    una fruta que posee informacion de sus respectivas caracteristicas.

    Returns
    -------
    Retorna un diccionario con el nombre de todos los colores asociadas a todas
    las frutas y su respectivo conteo, siendo la llave el nombre del color y el
    valor el numero total de frutas con ese color.
    """
    # C√≥digo Aqu√≠
    conteo = {}                #Diccionario vacio
    for fruta in datos:
      color = fruta["color"]
      if color in conteo:
        conteo[color] += 1     #Se rellena diccionario
      else:
        conteo[color] = 1
    return conteo

conteo_colores(datos)

"""**5. La funci√≥n `obtener_tipos` que devuelva una lista con los tipos √∫nicos de fruta usando `set()`**.

Por ejemplo, `obtener_tipos([limon, naranja, platano])` deber√≠a devolver `["citrica", "tropical"]`
"""

def obtener_tipos(datos):
    # Documentaci√≥n Aqu√≠
    """
    Summary
    Toma una lista de frutas (cada uno un diccionario) y retorna todos las
    caracteristicas asociadas al "Tipo" en forma de diccionario.

    Parameters
    ----------
    datos: Lista, esta conformada por diccionarios. Cada elemento corresponde a
    una fruta que posee informacion de sus respectivas caracteristicas.

    Returns
    -------
    Retorna un diccionario con el nombre de todos los tipos de frutas presentes
    en la lista ingresada, no se repiten elementos.
    """
    # C√≥digo Aqu√≠
    tipos = set()                #Se eliminan elementos repetidos
    for fruta in datos:
      tipos.add(fruta["tipo"])
    return tipos

"""**6. Genere tres test para cada una de las funciones de la pregunta 5 y as√≠ comprobar que funcionan correctamente.**

Se <u>sugiere</u> que se apoyen en las siguientes directrices:
- Test para tratar resultados nulos
- Test para un subconjunto interesante cuyo resultado no sea nulo
- Test para todos los datos

**Ejecuten esta celda para comprobar su c√≥digo:**
"""

# ---------------------------------------------------------------------
# test descripciones

assert describir([]) == [] # test 1
assert describir([naranja, pi√±a]) == ['La naranja es una fruta de tipo c√≠trica de color naranjo. Presenta pepas en su interior.','La pi√±a es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.']    # test 2
assert  describir(datos) == ['El lim√≥n es una fruta de tipo c√≠trica de color amarillo. Presenta pepas en su interior.',
                            'La naranja es una fruta de tipo c√≠trica de color naranjo. Presenta pepas en su interior.',
                            'El pl√°tano es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.',
                            'La pi√±a es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.',
                            'La frutilla es una fruta de tipo bosque de color rojo. Presenta pepas en su interior.',
                            'La frambuesa es una fruta de tipo bosque de color rojo. Presenta pepas en su interior.'] #Test 3

# ---------------------------------------------------------------------
# test filtro

assert filtrar_por_pepa([],True) == []  # test 1
assert filtrar_por_pepa([],False) == []
assert filtrar_por_pepa([naranja,limon],True) == ['naranja','lim√≥n']  # test 2
assert filtrar_por_pepa([naranja,limon],False) == []
assert filtrar_por_pepa(datos,True) == ['lim√≥n', 'naranja', 'frutilla', 'frambuesa'] #Test 3
assert filtrar_por_pepa(datos,False) == ['pl√°tano','pi√±a'] #Test 3

# ---------------------------------------------------------------------
# test conteo

assert conteo_colores([]) == {} # test 1
assert conteo_colores([naranja,limon]) == {'naranjo':1, 'amarillo':1} # test 2
assert conteo_colores(datos) == {'amarillo': 3, 'naranjo': 1, 'rojo': 2} # test 3

# ---------------------------------------------------------------------
# test tipos

assert obtener_tipos([]) == set() # test 1
assert obtener_tipos([limon, naranja, platano]) == {'c√≠trica', 'tropical'} # test 2
assert obtener_tipos(datos) == {'bosque', 'c√≠trica', 'tropical'} # test 3

"""**7. Programe nuevamente las funciones `describir`, `filtrar_por_pepa` y `obtener_tipos`, pero esta vez usando *comprehensions*.**

*Hint: Pueden reutilizar la documentaci√≥n escrita en la pregunta 5*
"""

def obtener_descripciones_v2(datos):
    # Documentaci√≥n Aqu√≠
    # C√≥digo Aqu√≠
    descripciones = [generar_descripcion(fruta) for fruta in datos]
    return descripciones

def filtrar_por_pepa_v2(datos, tiene_pepas):
    # Documentaci√≥n Aqu√≠
    # C√≥digo Aqu√≠
    filtrados = [fruta["nombre"] for fruta in datos if fruta["pepas"] == tiene_pepas]
    return filtrados

def obtener_tipos_v2():
    # Documentaci√≥n Aqu√≠
    # C√≥digo Aqu√≠
    tipos = {fruta["tipo"] for fruta in datos}
    return tipos

obtener_descripciones_v2([limon, naranja])

# test descripciones v2
assert obtener_descripciones_v2([]) == [] # test 1
assert obtener_descripciones_v2([naranja, pi√±a]) == ['La naranja es una fruta de tipo c√≠trica de color naranjo. Presenta pepas en su interior.','La pi√±a es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.']    # test 2
assert  obtener_descripciones_v2(datos) == ['El lim√≥n es una fruta de tipo c√≠trica de color amarillo. Presenta pepas en su interior.',
                            'La naranja es una fruta de tipo c√≠trica de color naranjo. Presenta pepas en su interior.',
                            'El pl√°tano es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.',
                            'La pi√±a es una fruta de tipo tropical de color amarillo. No presenta pepas en su interior.',
                            'La frutilla es una fruta de tipo bosque de color rojo. Presenta pepas en su interior.',
                            'La frambuesa es una fruta de tipo bosque de color rojo. Presenta pepas en su interior.'] #Test 3

"""## Parte 2: Electrodom√©sticos [2.5 puntos]

En esta parte se solicitar√°n un par de clases que permitir√° jugar con la Programaci√≥n Orientada a Objetos.

<div align='center'>
<img src='https://upload.wikimedia.org/wikipedia/commons/6/67/Breville.jpg' width=400/>
</div>


### Clase Electrodom√©stico [0.5 puntos]

Defina la clase `Electrodomestico` que implemente:


- Un constructor que defina un atributo de instancia llamado `enchufado` que almacene valores booleanos.
- Un m√©todo llamado `esta_enchufado(self)` que levante una excepci√≥n `Exception` y que termine con la ejecuci√≥n del programa cuando el atributo enchufado sea `False`. La excepci√≥n debe levantar el mensaje `'Alerta ‚ö†Ô∏è: El electrodom√©stico no est√° enchufado'`
- Un m√©todo llamado `enchufar(self)` que cambia el estado de `enchufado` a True.


"""

class Electrodomestico:
  def __init__(self):
    # C√≥digo Aqu√≠
    self.enchufado = False
  def esta_enchufado(self):
    # C√≥digo Aqu√≠
    if not self.enchufado:
      raise Exception('Alerta ‚ö†Ô∏è: El electrodom√©stico no est√° enchufado')
  def enchufar(self):
    # C√≥digo Aqu√≠
    self.enchufado = True

Probar_enchufado = Electrodomestico()
Probar_enchufado.enchufar()

Probar_enchufado.esta_enchufado()

"""### Clase Jugera [1.0 puntos]


<div align='center'>
<img src='https://upload.wikimedia.org/wikipedia/commons/b/bb/Liquadora_%28parts%29.JPG' width=400/>
</div>


Implemente la clase `Jugera` que extiende `Electrodomestico` y que implemente:


- Un constructor que tenga una lista de ingredientes frutales (llamado `bandeja`).


- Un m√©todo llamado `agregar_ingrediente(self, nueva_fruta)` que dado una fruta, agregue esa fruta a la `bandeja`.

- Un m√©todo llamado `listar_ingredientes(self)` que imprima (con `print`) los ingredientes actuales de la `bandeja` de la siguiente forma:

    `Ingredientes en la bandeja: frutilla, frambuesa, pi√±a.`

De lo contrario si no tiene ingredientes imprima:

    `Bandeja vac√≠a`


**Hint:** Investigar el m√©todo `join` de un string para generar el string con los nombres de las frutas.
    
    
    

- Un m√©todo llamado `preparar_jugo(self)` que:
    - Primero verifique que el electrodom√©stico est√© enchufado usando `self.esta_enchufado()`.
    - Verifique que haya por lo menos un ingrediente en la `bandeja`. En el caso que no haya, levantar una excepci√≥n con contenido `'Error ‚ùå: La bandeja no tiene ingredientes.'`
    - Verifique que ninguna fruta tenga pepas. En el caso que haya alguna, imprimir (con `print`) el mensaje de advertencia `'Alerta ‚ö†Ô∏è: El jugo puede contener restos de pepas.'`. Puede usar la funci√≥n definida en la secci√≥n anterior.
    - Genere un mensaje indicado `Jugo de {nombres de las frutas separadas por una ,} listo. üèñÔ∏èü•§ Que lo disfrutes!!! ü•§üèñÔ∏è. ` (Hint: Usar nuevamente `join`).
    - Vacie la `bandeja` (es decir, eliminar todas las frutas de la bandeja).
    - Retorne el mensaje generado.

"""

class Jugera(Electrodomestico):

    def __init__(self):
      super().__init__()
      self.bandeja = []

      # C√≥digo Aqu√≠

    def agregar_ingrediente(self, nueva_fruta):
        # C√≥digo Aqu√≠
        self.bandeja.append(nueva_fruta)

    def listar_ingredientes(self):
        # C√≥digo Aqu√≠
        string = 'Ingredientes en la bandeja: '
        for i in range(len(self.bandeja)):
          string = string + self.bandeja[i]['nombre']
          if i == len(self.bandeja)-1:
            string = string + "."
            print(string)
          else:
            string = string + ", "
        if len(self.bandeja) == 0:
          print('La bandeja esta vacia.')

    def preparar_jugo(self):
        # C√≥digo Aqu√≠
        self.esta_enchufado()
        if len(self.bandeja) == 0:
          raise Exception('Error ‚ùå: La bandeja no tiene ingredientes.')
        frutas_con_pepas = filtrar_por_pepa(datos,True)
        for i in self.bandeja:
          if i['nombre'] in(frutas_con_pepas):
            print('Alerta ‚ö†Ô∏è: El jugo puede contener restos de pepas.')
            break
        nombres = []
        for i in self.bandeja:
          nombres.append(i['nombre'])
        mensaje = ", ".join(nombres)
        mensaje_final = 'Jugo de '+ mensaje + ' listo. üèñÔ∏èü•§ Que lo disfrutes!!! ü•§üèñÔ∏è.'
        self.bandeja = []
        print(mensaje_final)

"""### Interacciones

Las siguientes celdas les permitir√°n probar las interacciones de esta clase.
La ejecuci√≥n es solo referencial y no lleva puntaje. La idea es que la utilice como gu√≠a para desarrollar la clase.
"""

jugera = Jugera()

# Como no tenemos ingredientes, listar_ingredientes deber√° imprimir 'Bandeja vac√≠a'
jugera.listar_ingredientes()

# Esta celda deber√≠a levantar una excepcion indicando que no est√° enchufada la jugera.
jugera.preparar_jugo()

# Enchufamos el electrodom√©stico
jugera.enchufar()

# Esta celda deber√≠a levantar ina excepci√≥n informandoles que la bandeja no tiene ingredientes.
jugera.preparar_jugo()

# Agregamos algunos ingredientes
jugera.agregar_ingrediente(naranja)
jugera.agregar_ingrediente(platano)

# Y los listamos (deber√≠a imprimir: 'Ingredientes en la bandeja: naranja, pl√°tano')
jugera.listar_ingredientes()

# Preparamos el jugo: 'Jugo de naranja, pl√°tano listo. üèñÔ∏èü•§ Que lo disfrutes!!! ü•§üèñÔ∏è.'
jugera.preparar_jugo()

# Una vez preparado el jugo, deber√≠a vaciarse la bandeja (imprimir Bandeja vac√≠a)
jugera.listar_ingredientes()

"""### Clase Jugera + Properties  [1.0 puntos]

Implementar `bandeja` usando una `property` que permita setear una `nueva_bandeja` como `bandeja` seg√∫n las siguientes condiciones:


- Compruebe que `nueva_bandeja` sea una lista. En caso contrario, levante una excepci√≥n.
- No permita agregar m√°s de 3 ingredientes a la bandeja a la vez. Si se entregan m√°s de 3 frutas, se levante una excepci√≥n.
- Se compruebe que todos los elementos de la lista sean frutas. Para esto, por cada fruta compruebe que:
    1. La fruta sea diccionario.
    2. El diccionario entregado tenga las llaves `nombre`, `tipo`, `color` y `pepas`.
"""

class Jugera(Electrodomestico):

    def __init__(self):
        # C√≥digo Aqu√≠
        super().__init__()
        self._bandeja = None

    @property
    def bandeja(self):
        # C√≥digo Aqu√≠
        return self._bandeja

    @bandeja.setter
    def bandeja(self, nueva_bandeja):
        # C√≥digo Aqu√≠
        diccionario_keys = ['nombre', 'tipo', 'color', 'pepas']
        if not isinstance(nueva_bandeja,list):
          raise Exception('Error nueva_bandeja no es una lista')
        if len(nueva_bandeja) > 3:
          raise Exception('Error la bandeja tiene mas de 3 ingredientes')
        for j in nueva_bandeja:
          if isinstance(j,dict):
              for i in nueva_bandeja:
                a = list(i.keys())
                if a != diccionario_keys:
                  raise Exception('Coloque un ingrediente que sea una fruta')
          else:
            raise Exception('Coloque un ingrediente que sea una fruta')
        self._bandeja = nueva_bandeja

    def agregar_ingrediente(self, nueva_fruta):
        # C√≥digo Aqu√≠
        self.ingredientes.append(nueva_fruta)

    def listar_ingredientes(self):
        # C√≥digo Aqu√≠
        if self._bandeja == None:
          print('La bandeja no tiene ingredientes.')
        else:
          string = 'Ingredientes en la bandeja: '
          nombres = []
          for i in self._bandeja:
            nombres.append(i['nombre'])
          mensaje = ", ".join(nombres)
          mensaje_final = string + mensaje
          print(mensaje_final)

    def preparar_jugo(self):
        # C√≥digo Aqu√≠
        self.esta_enchufado()
        if self._bandeja == None:
          raise Exception('Error ‚ùå: La bandeja no tiene ingredientes.')
        frutas_con_pepas = filtrar_por_pepa(datos,True)
        for i in self._bandeja:
          if i['nombre'] in(frutas_con_pepas):
            print('Alerta ‚ö†Ô∏è: El jugo puede contener restos de pepas.')
            break
        nombres = []
        for i in self._bandeja:
          nombres.append(i['nombre'])
        mensaje = ", ".join(nombres)
        mensaje_final = 'Jugo de '+ mensaje + ' listo. üèñÔ∏èü•§ Que lo disfrutes!!! ü•§üèñÔ∏è.'
        self._bandeja = None
        print(mensaje_final)

"""### Interacciones

Las siguientes celdas les permitir√°n probar las interacciones de esta clase.
La ejecuci√≥n es solo referencial y no lleva puntaje. La idea es que la utilice como gu√≠a para desarrollar la clase.
"""

jugera_2 = Jugera()

jugera_2.listar_ingredientes()

jugera_2.preparar_jugo()

# Enchufamos el electrodom√©stico
jugera_2.enchufar()

# Esta celda deber√≠a levantar ina excepci√≥n informandoles que la bandeja no tiene ingredientes.
jugera_2.preparar_jugo()

# Agregamos algunos ingredientes (en este caso, como son m√°s de 3, fallar√°)
jugera_2.bandeja = [naranja, platano, frutilla, limon]

# Agregamos algunos ingredientes
# (en este caso deber√≠a fallar, ya que estamos entregando un string en el primer lugar)
jugera_2.bandeja = ["naranja", platano, frutilla]

# Agregamos algunos ingredientes
# (en este caso deber√≠a fallar, ya que ar√°ndando tiene solo la llave nombre)
jugera_2.bandeja = [{'nombre': 'ar√°ndano'}, platano, frutilla]

# Agregamos algunos ingredientes (en este caso, como son 3, deber√≠a funcionar)
jugera_2.bandeja = [naranja, platano, frutilla]

# Y los listamos (deber√≠a imprimir: 'Ingredientes en la bandeja: naranja, pl√°tano')
jugera_2.listar_ingredientes()

# Una vez preparado el jugo, imprima el contenido del jugo y si una alerta,
# en el caso que el jugo tenga pepas.
jugera_2.preparar_jugo()

# Una vez preparado el jugo, deber√≠a vaciarse la bandeja (imprimir Bandeja vac√≠a)
jugera_2.listar_ingredientes()

"""## Parte 3 [1.0 puntos]

Para esta √∫ltima parte, deben responder las siguientes preguntas:

1. ¬øQu√© es un virtual environment? ¬øPara qu√© sirve? (0.25 ptos)

`Escriba su respuesta ac√°`

Un entorno virtual es un entorno Python en el que se puede crear y gestionar entornos aislados, es decir, el int√©rprete, las bibliotecas y los scripts instalados en √©l est√°n aislados de los instalados en otros entornos virtuales, y (por defecto) cualquiera que est√© instalado como parte de tu sistema operativo.

La creaci√≥n de un entorno virtual nos sirve cuando se trabajan diferentes proyectos de software al mismo tiempo, ya que cada uno requiere diferentes versiones y dependencias por lo que el entorno logra mantener una consistencia e independencia de cada uno.


2. ¬øQu√© ventajas puede tener usar un virtual environment? Nombre y explique al menos 2. (0.25 ptos)

`Escriba su respuesta ac√°`

Seguridad:

Al usar un entorno virtual, se pueden utilizar bibliotecas y dependencias sin la preocupaci√≥n de que afecte el sistema global de la computadora. Si algo sale mal o se necesita eliminar un proyecto, simplemente se puede eliminar el entorno virtual asociado sin dejar rastros en el sistema operativo principal.

Gesti√≥n eficiente de proyectos:

Al utilizar un entorno virtual, se puede cambiar entre diferentes proyectos sin preocupaci√≥n por posibles conflictos de bibliotecas o problemas de compatibilidad.


3. Escriba el comando para crear un virtual environment usando `conda`. ¬øExisten otras formas de crear un virtual environment? (0.25 ptos)

`Escriba su respuesta ac√°`

conda create --name nombre_del_entorno

Existen diferentes formas de crear un entorno virtual seg√∫n el lenguaje de programaci√≥n que se utilice, por ejemplo si seguimos con Python se puede usar tambi√©n  virtualenv o el m√≥dulo venv, mientras que los dem√°s lenguajes tienen diferentes formas de manejar entornos virtuales


4. ¬øDe qu√© forma podemos exportar las librerias instaladas en un virtual environment? Escriba el comando que nos permite realizar esto.  (0.25 ptos)

`Escriba su respuesta ac√°`

Para poder exportar librer√≠as instaladas en un entorno virtual se puede generar un archivo txt que contenga los requerimientos del entorno virtual de la forma:

Pip freeze > requirements.txt

Dicho archivo contiene una lista de todas las librer√≠as con las versiones necesarias para el entorno virtual y se instalan de la forma:

Pip install -r requirements.txt

<a style='text-decoration:none;line-height:16px;display:flex;color:#5B5B62;padding:10px;justify-content:end;' href='https://deepnote.com?utm_source=created-in-deepnote-cell&projectId=87110296-876e-426f-b91d-aaf681223468' target="_blank">
<img alt='Created in deepnote.com' style='display:inline;max-height:16px;margin:0px;margin-right:7.5px;' src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iODBweCIgaGVpZ2h0PSI4MHB4IiB2aWV3Qm94PSIwIDAgODAgODAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDU0LjEgKDc2NDkwKSAtIGh0dHBzOi8vc2tldGNoYXBwLmNvbSAtLT4KICAgIDx0aXRsZT5Hcm91cCAzPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkxhbmRpbmciIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJBcnRib2FyZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEyMzUuMDAwMDAwLCAtNzkuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjM1LjAwMDAwMCwgNzkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aC0yMCIgZmlsbD0iIzAyNjVCNCIgcG9pbnRzPSIyLjM3NjIzNzYyIDgwIDM4LjA0NzY2NjcgODAgNTcuODIxNzgyMiA3My44MDU3NTkyIDU3LjgyMTc4MjIgMzIuNzU5MjczOSAzOS4xNDAyMjc4IDMxLjY4MzE2ODMiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNS4wMDc3MTgsODAgQzQyLjkwNjIwMDcsNzYuNDU0OTM1OCA0Ny41NjQ5MTY3LDcxLjU0MjI2NzEgNDguOTgzODY2LDY1LjI2MTk5MzkgQzUxLjExMjI4OTksNTUuODQxNTg0MiA0MS42NzcxNzk1LDQ5LjIxMjIyODQgMjUuNjIzOTg0Niw0OS4yMTIyMjg0IEMyNS40ODQ5Mjg5LDQ5LjEyNjg0NDggMjkuODI2MTI5Niw0My4yODM4MjQ4IDM4LjY0NzU4NjksMzEuNjgzMTY4MyBMNzIuODcxMjg3MSwzMi41NTQ0MjUgTDY1LjI4MDk3Myw2Ny42NzYzNDIxIEw1MS4xMTIyODk5LDc3LjM3NjE0NCBMMzUuMDA3NzE4LDgwIFoiIGlkPSJQYXRoLTIyIiBmaWxsPSIjMDAyODY4Ij48L3BhdGg+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMCwzNy43MzA0NDA1IEwyNy4xMTQ1MzcsMC4yNTcxMTE0MzYgQzYyLjM3MTUxMjMsLTEuOTkwNzE3MDEgODAsMTAuNTAwMzkyNyA4MCwzNy43MzA0NDA1IEM4MCw2NC45NjA0ODgyIDY0Ljc3NjUwMzgsNzkuMDUwMzQxNCAzNC4zMjk1MTEzLDgwIEM0Ny4wNTUzNDg5LDc3LjU2NzA4MDggNTMuNDE4MjY3Nyw3MC4zMTM2MTAzIDUzLjQxODI2NzcsNTguMjM5NTg4NSBDNTMuNDE4MjY3Nyw0MC4xMjg1NTU3IDM2LjMwMzk1NDQsMzcuNzMwNDQwNSAyNS4yMjc0MTcsMzcuNzMwNDQwNSBDMTcuODQzMDU4NiwzNy43MzA0NDA1IDkuNDMzOTE5NjYsMzcuNzMwNDQwNSAwLDM3LjczMDQ0MDUgWiIgaWQ9IlBhdGgtMTkiIGZpbGw9IiMzNzkzRUYiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+' > </img>
Created in <span style='font-weight:600;margin-left:4px;'>Deepnote</span></a>
"""